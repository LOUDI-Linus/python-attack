"""
@file: 1.引用计数
@author: Cooper.wy_zou1103@163.com
@date: 2021/03/25
@decs

浅拷贝是将对象的引用复制给另一个对象,拷贝的只是原子对象元素的引用，换句话说，
浅拷贝产生的对象, 本身是新的，
但是它的内容不是新的，只是对原子对象的一个引用。
副本中进行修改时会影响原对象。

深拷贝就是在内存中重新开辟一块空间，不管数据结构多么复杂，只要遇到可能发生改变的数据类型，
就重新开辟一块内存空间把内容复制下来，直到最后一层
是将对象本身复制给另一个对象


不可变数据类型，不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，
在内存中则只有一个对象，就是不可变数据类型引用的地址的值不可改变
改变对象的值，其实是引用了不同的对象


可变数据类型，允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址不会改变，
只是对应地址的内容改变或者地址发生了扩充，所以对于相同的值的不同对象，会存在多份，即每个对象都有自己的地址


引用复制（赋值拷贝）

“=”多了几个变量指向同一个地址，
"""
from sys import getrefcount
# 凡是使用a = b  => a和b一定是同一个对象
# a = 5
# b = a
# print(id(a), id(b))
# print(a is b)
#
# a = a+2
# # 5+2 => 7 => a
# print(a is b)


# # 凡是使用a = b  => a和b一定是同一个对象
# a = [1,2,3]
# b = a
# print(id(a), id(b))
# print(a is b)
# # 赋值运算从右到左， a+[3] 产生了一个新对象
# a = a + [3]
# print(a is b)
# # 如果a is b的结果是True, 意味着a [1,2,3,3], b [1,2,3,3]
# print(a, b)
#

# # 凡是使用a = b  => a和b一定是同一个对象
# a = [1,2,3]
# b = a
##直接在内存地址上做操作，所以id不变，没有新生成对象
# a += [3]
# print(a is b)
# print(a, b)




# a = {1: [1,2,3]}
# b = a
#
# # a和b是引用的对象是同一个地址0x0001
# #
#
# a[2] = "No.2"
# b[1].append(4)
#
# print(a is b)
# print(a, b)

# #字典浅拷贝，拷贝第一层地址
# import copy
# a = {1: [1,2,3]}
# b = a.copy() #等效下边
# # b = copy.copy(a)
# # a和b是引用的对象是同一个地址0x0001
# print(a[1])
# a[2] = "No.2"
# b[1].append(4)
#
# print(a is b)
# print(a, b)


# import copy
# a = {1: [1,2,3]}
# b = copy.deepcopy(a)
# # a和b是引用的对象是同一个地址0x0001
#
# a[2] = "No.2"
# b[1].append(4)
#
# print(a is b)
# print(a, b)

# 如果以后对数据做拷贝，一定要记得它的这个特性。

